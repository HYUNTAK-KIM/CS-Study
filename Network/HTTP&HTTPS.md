# HTTP & HTTPS

## HTTP(HyperText Transfer Protocol)

인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약

### HTTP/1.1
  
평문 기반 프로토콜
  
- 특징
  1. Pipelining
  
       클라이언트가 서버에 다수의 요청을 보내고 서버는 응답을 차례대로 반환  
        > 과거의 방식 : 요청을 다시 보내기 위해 이전의 요청에 대한 응답을 기다렸음
  
        과거의 방식과 달리 네트워크 대기 시간이 줄어듬  

        > instruction pipeline : 프로세서가 하나의 명령어를 실행하는 도중에 다른 명령어를 실행하는 기법, 여러개의 명령어를 동시에 수행한다.

  2. Persistence Connection
  
       단일 TCP 연결을 통해 여러 HTTP 요청을 연속적으로 보낼 수 있음  
       오버헤드 제거 : 각 요청마다 새로운 연결을 생성하지 않음

      > HTTP/1.0에서는 HTTP Header에 Connection: keep-alive을 붙여야 해당 기능을 지원

  3. Chunked transfer encoding
  
       서버에서 응답 데이터를 청크로 나누어 전송  
       서버가 응답 전체를 준비하지 않고도 클라이언트로 데이터를 전송할 수 있게 함

  4. Host Header

      하나의 IP에 여러 도메인이 매핑되어있을떄 사용
      Host Header를 통해 어느 도메인으로 들어왔는지 알 수 있음

### HTTP/2.0
  
바이너리 기반 프로토콜  
HTTP/1.1에선 요청과 응답이 Message 단위로 구성되어 있었습니다.  
HTTP/2.0에선 Message외에 Frame, Stream 개념이 추가되었습니다.  

- 특징

  1. 바이너리 프레이밍

        어플리케이션 레이어에서부터 바이너리 프레임으로 변환
        구문 분석에 효율적
       > 속도 : 바이너리 데이터 인코딩/디코딩 처리 속도 > 문자열 데이터의 인코딩/ 디코딩 처리 속도

  2. 헤더 압축

        헤더 압축 기법을 사용하여 헤더 크기를 줄임

  3. 멀티플렉싱

        하나의 TCP 연결 내에서 여러 스트림을 통해 동시다발적인 요청과 응답이 가능

        > Stream은 하나의 TCP 연결에서 여러개의 Stream을 구성할 수 있습니다. Stream은 여러개의 Frame을 보낼 수 있습니다.

        **여러개의 Stream이 구성되어있다고 하지만, TCP 연결이 하나인 경우 여전히 물리적으론 하나의 연결입니다**
        > [하나의 TCP 연결]  
        | Stream A: Header Frame | Stream B: Header Frame | Stream A: Data Frame | Stream B: Data Frame | Stream A: Data Frame | ...

  4. HTTP HOLB 문제 해결

          바이너리 데이터로 이루어져 있어 빠르고 효율적이면 네트워크 친화적입니다.

  5. 서버 푸시

       클라이언트가 요청하지 않은 데이터를 서버에서 미리 보내 브라우저에 캐싱해놓는 기능  
       서버가 HTML 문서에 필요한 리소스들을 미리 파악해서 클라이언트에게 전송

     ![](https://blog.apnic.net/wp-content/uploads/2018/04/HTTP2_1.png)

  6. Selectively Push
  
     HTTP/2.0은 리소스를 푸시할지 여부를 결정하는 것에 대해 다루지 않습니다.  
     즉, Server Push는 클라이언트가 리소스를 필요로 할 가능성이 높고 이미 캐시되어 있지 않을 경우에만 리소스를 푸시하는 것이 가장 좋습니다.  
     브라우저에 캐시되어 있는데 응답을 보내면 낭비겠죠.  
     한 가지 가능한 접근 방법은 클라이언트가 사이트를 처음 방문할 때만 리소스를 푸시하는 것입니다.  
     예를 들어 세션 쿠키의 존재 여부를 테스트하고, 조건부로 Link 헤더를 설정하여 세션 쿠키가 없는 경우에만 리소스를 preload할 수 있습니다.  
     이 방법을 사용하면 GET 요청의 2RTT를 1RTT로 줄일 수 있습니다.

  7. Stream Prioritization
  
     스트림들의 우선순위를 1~256의 가중치를 할당하여 정해줍니다.  
     용량이 크고 중요하지않은 데이터를 후순위로 미룰 수 있게 합니다.  

<details>
<summary>HTTP/3.0 이전 버전의 문제점</summary>
  1. HTTP HOLB(head of line blocking)

      HTTP/1.1 이전의 요청/응답은 동기적으로 진행됐습니다. 
      즉,  1. 사진을 요청 -> 응답 -> 2. css 파일을 요청 -> 응답 ... 이런 식으로 작동합니다.
      이를 개선한기 위해 HTTP 1.1은 pipelining이란 개념을 도입했습니다. pipelining이란 응답을 기다리지 않고 요청을 미리 보내는 것입니다. 1. 사진을 요청 > 1-1. css 파일을 요청 => 사진 응답, css 응답 ... 와 같이 작동합니다.
      한계점 :
      그래도 요청은 순서대로 처리된다는 단점이 존재했는데 이를 HOLB 문제라 합니다.

          line => 데이터 패킷, head는 데이터 패킷의 맨 앞, blocking은 운영체제의 I/O blocking과 비슷하다 생각하시면 이해하기 편합니다.
  위의 HOLB는 HTTP/2.0에서 해결됩니다. 멀티플렉싱이란 개념을 도입하여 요청/응답을 병렬적으로 처리합니다.
  > 멀티플렉싱이란? 하나의 TCP 연결에서 여러 스트림을 동시에 처리할 수 있게 해주는 기술

  그러나 TCP 단의 HOLB는 해결하지 못했습니다(~HTTP/2.0은 TCP 위에서 작동)

  2.TCP HOLB

      TCP 상에서 전송된 패킷이 손실되면 재전송을 합니다. 이 때 TCP 순서를 보장해주기 위해 후속 패킷들은 대기하게 됩니다. -> Blocking

- 순서 보장을 위해선 막아야 되는 거 아닌가요?

         서로 연관된 패킷은 순서보장을 위해 순차적으로 처리해야합니다. 하지만 TCP HOLB는 해당 스트림을 막는다는 것이 문제입니다. 그래서 연관되지 않은 패킷들도 blocking 됩니다.
- TCP를 여러개 사용하면 되는 거 아닌가요?

         TCP는 연결할 때마다 3-way handshake를 수행하는데 이는 지연 시간을 증가시키고 오버헤드가 생깁니다.

     **결론 : 이를 해결하기 위해 HTTP/3.0은 UDP기반인 QUIC 프로토콜을 사용합니다**

</details>

## HTTP/3.0

TCP의 Handshake, TCP의 HOLB(순서 보장)의 latency를 해결하기 위해 나온 프로토콜  
GOOGLE의 QUIC 프로토콜을 기반으로 사용합니다.  

> QUIC 프로토콜이란?  
  QUIC은 어플리케이션 레이어 일부, TLS 레이어 포함, 그리고 전송 계층 일부에 구현되어 있습니다.  
  TLS 레이어를 포함하기 때문에 TLS를 통한 HTTPS가 필수적으로 요구됩니다.  
  또한 QUIC 프로토콜에는 HTTP/2.0의 멀티플렉싱 등 대부분 기능이구현되어 있습니다.
  
  1. 빠른 연결 설정 : RTT 시간 감소  
     기존의 HTTP는 TCP Handshake, TLS Handshake를 사용하여 2 RTT의 시간이 소요되었는데, QUIC은 UDP위에서 구현되어 TLS layer를 합쳐 이를 1 RTT or 0 RTT로 해결합니다.

  2. TCP HOLB 문제 해결  
       스트림 기반 전송 : 스트림마다 버퍼 생성  
       HTTP/3.0의 스트림은 독립적으로 운영되기 때문에 하나의 스트림이 막혀도 다른 스트림에 영향을 주지 않습니다.
       packet loss되어도 해당 packet의 스트림만 막히고 다른 스트림에는 영향이 없습니다. (스트림마다 버퍼가 생김)

- 왜 TCP를 수정하거나 새로운 프로토콜을 만들지 않고 UDP 위에서 구현했을까요?

   새로운 전송 프로토콜을 만드는 건 정말 어려운 일입니다. 또한, 보안을 위해 네트워크를 거치는 장비들이 익숙하지 않은 프로토콜을 차단할 수 있고, 방화벽이나 라우터가 이를 막을 가능성도 있어요.

   그리고 TCP를 변경하는 것도 쉽지 않습니다. TCP는 운영체제의 핵심 부분에 포함되어 있어서 수정하려면 모든 기기의 운영체제를 업데이트해야 합니다. 이는 수십 년이나 걸릴 수 있는 큰 작업이죠.

## HTTPS(HyperText Transfer Protocol Secure)

HTTP를 암호화시킨 것

- 왜 암호화를 시켜야 합니까?
  HTTP를 평문으로 전송할 경우, 데이터는 목적지에 도달하기 위해 수많은 라우터와 스위치를 거치게 됩니다. 이 과정에서 스니핑(sniffing) 공격을 통해 타인이 내 민감한 데이터를 쉽게 도청할 수 있습니다. 따라서 민감한 정보를 안전하게 전달하기 위해서는 암호화가 필수적입니다.

- 어떻게 암호화 시키나요?
  **TLS (Transport Layer Security)**를 사용하여 HTTP를 암호화합니다. TLS는 대칭키 암호화와 비대칭키(공개키) 암호화를 결합한 방식으로 보안을 제공합니다. 또한, **인증 기관(CA, Certificate Authority)**을 통해 서버의 신원을 검증받습니다.

TLS를 이용한 암호화 과정:

1. 인증서 발급:

   서버는 **키 쌍(공개키와 개인키)**을 생성합니다.
   서버는 CA에 **인증서 서명 요청(Certificate Signing Request, CSR)**을 보내고, CA는 서버의 공개키를 포함한 인증서를 발급합니다.
2. 인증서 전달:

   서버는 클라이언트와 연결을 수립할 때, 이 인증서를 클라이언트에게 전달합니다.
3. 인증서 검증:

   클라이언트는 브라우저나 운영체제에 미리 신뢰된 CA의 공개키를 사용하여 서버의 인증서를 검증합니다.
   인증서가 유효하면, 인증서에 포함된 서버의 공개키를 추출합니다.
4. 세션 키 설정:

   클라이언트는 **세션 키(대칭키)**를 생성하고, 서버의 공개키로 이 세션 키를 암호화하여 서버에 전송합니다.
   서버는 자신의 개인키로 암호화된 세션 키를 복호화하여 대칭키를 획득합니다.
5. 데이터 암호화 및 전송:

   클라이언트와 서버는 이제 공유된 대칭키를 사용하여 데이터를 암호화하고 안전하게 주고받습니다.

- 처음 서버에서 클라이언트로 인증서를 보낼 때 공격자가 인증서를 가로채면 대칭키가 탈취되는 거 아닌가요?
공격자가 인증서를 가로챘다고 하더라도 HTTPS 데이터는 안전합니다. 그 이유는 다음과 같습니다:

- 인증서의 역할: 인증서는 서버의 공개키를 포함하고 있으며, 이 공개키는 비대칭키 암호화에 사용됩니다.
- 대칭키 암호화: 클라이언트는 서버의 공개키로 세션 키(대칭키)를 암호화하여 서버에 전송합니다. 이 암호화된 세션 키는 서버의 개인키로만 복호화할 수 있습니다.
- 보안 유지: 공격자가 인증서를 가로채더라도, 공개키만 얻을 수 있으며 개인키를 알지 못하기 때문에 세션 키를 탈취할 수 없습니다. 따라서 데이터는 여전히 안전하게 보호됩니다.

  > 용어 정리:
  > - 공개키 (Public Key): 암호화에 사용되는 키로, 누구나 접근할 수 있습니다. 비대칭키 방식에서 사용됩니다.
  > - 개인키 (Private Key): 복호화에 사용되는 비밀 키로, 서버만이 보유합니다.
  > - 대칭키 (Symmetric Key): 암호화와 복호화에 동일한 키를 사용하는 방식으로, 빠르고 효율적입니다.
  > - 인증서 (Certificate): CA가 발급하는, 서버의 신원을 검증하는 문서로, 서버의 공개키를 포함합니다.

- 서버가 인증서를 발급하는 주체가 될 수 없나요?

    서버도 **자체 인증서(Self-Signed Certificate)**를 발급할 수 있습니다. 예를 들어, mkcert와 같은 도구를 사용하여 로컬 개발 환경에서 HTTPS를 설정할 수 있습니다. 이러한 자체 인증서는 다음과 같은 상황에서 유용합니다:

  - 로컬 개발: 배포 서버와 유사한 환경에서 테스트를 진행할 수 있어 개발에 유리합니다.
  - 제한된 환경: 특정 기능이 HTTP 대신 HTTPS에서만 동작하는 라이브러리나 서비스가 있는 경우, 로컬에서도 HTTPS를 사용해야 합니다.
    단, 자체 인증서는 공인된 CA에 의해 검증되지 않기 때문에, 브라우저에서는 보안 경고가 표시될 수 있습니다. 따라서 공개된 서비스에서는 반드시 신뢰할 수 있는 CA로부터 발급받은 인증서를 사용해야 합니다.

- SSL과 TLS의 차이는 무엇인가요?

    SSL (Secure Sockets Layer): TLS의 전신으로, 초기 버전부터 보안 프로토콜로 사용되었습니다. 현재는 더 이상 사용되지 않으며, 보안상의 이유로 TLS로 대체되었습니다.
    TLS (Transport Layer Security): SSL의 향상된 버전으로, 현재 인터넷 보안의 표준 프로토콜입니다. SSL이라는 용어는 여전히 많이 사용되지만, 실제로는 거의 TLS를 지칭하는 경우가 많습니다.
